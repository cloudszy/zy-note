## 网络编程

        * 各种协议
             
             1. TCP （传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。
                在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内[1]  另一个重要的传输协议。
                在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。
                不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换
                
             2. IP （网络之间互连的协议）网络之间互连的协议（IP）是Internet Protocol的外语缩写，[1]  中文缩写为“网协”.
                网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议。
                在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。
                任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。
                IP地址具有唯一性，根据用户性质的不同，可以分为5类。另外，IP还有进入防护，知识产权，指针寄存器等含义。
                
             3. UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 
                参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17
                
             4. ICMP是（Internet Control Message Protocol）Internet控制报文协议。
                它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
                控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。
                这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。    
                
             5. "端口"是英文port的意译，可以认为是设备与外界通讯交流的出口。
                端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。
                例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。
                电话使用RJ11插口也属于物理端口的范畴。
                
             6. SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
                SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。
                通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。
                SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。
                
             7. FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。
                同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。
                在FTP的使用当中，用户经常遇到两个概念："下载"（Download）和"上传"（Upload）。
                "下载"文件就是从远程主机拷贝文件至自己的计算机上；"上传"文件就是将文件从自己的计算机中拷贝至远程主机上。
                用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。
                

                
        
        
        * 网络编程
        
            1. 从互联网诞生以来，现在基本上所有的程序都是网络程序，很少有单机版的程序了
            2. 计算机网络就是把各个计算机连接到一起，让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信
            3. 举个例子，当你使用浏览器访问新浪网时，你的计算机就和新浪的某台服务器通过互联网连接起来了
            4. 然后，新浪的服务器把网页内容作为数据通过互联网传输到你的电脑上
            5. 由于你的电脑上可能不止浏览器，还有QQ、Skype、Dropbox、邮件客户端等，不同的程序连接的别的计算机也会不同
            6. 所以，更确切地说，网络通信是两台计算机上的两个进程之间的通信
            7. 比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信
            8. 网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，
            9. 就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信
            
    
    
         * TCP/IP 简介
         
           1. 虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多
           2. 计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议
           3. 互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了
           4. 为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议
           5. 为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准
           6. Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络
           7. 有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网
           8. 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议
           9. 通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址
           10. 互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123
           11. 如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址
           12. 所以，IP地址对应的实际上是计算机的网络接口，通常是网卡
           13. P协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去
           14. 由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去
           15. IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达
           16. TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达
           17. TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发
           18. 许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等
           19. 一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口
           20. 端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序
           21. 一个IP包来了之后，到底是交给浏览器还是QQ，就需要端口号来区分
           22. 每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号
           23. 一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口
           
           
           
         * TCP编程
         
           1. Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”
           2. 而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可
           
    
         * 客户端
         
            1. 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器
            2. 举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接
            3. 如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了
            4. 所以，我们要创建一个基于TCP连接的Socket，可以这样做：
            
               ```python
               
               import socket
               
               s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
               
               s.connect(('www.sina.com.cn', 80))
               
               ```
               
            5. 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。
               SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。
               
            6. 服务器端口号必须固定，web服务的标准端口是80，SMTP(简单邮件传输协议)标准端口是25，FTP(文件传输协议)是21。
               端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。
               
               s.send('GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')
               
            7. TCP连接创建的是双向通道，双方都可以同时给对方发数据。
               但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。
               
               ```python
               
               buffer = []
               
               while True:
               
                     d = s.recv(1024)
                     
                     if d:
                     
                            buffer.append(d)
                            
                     else:
                     
                            break
                            
               data = ''.join(buffer)
               
               
             8. 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，
                因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。
                当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：
                
                s.close()
                
             9. 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件
                 
                 headr,html = data.split('\r\n\r\n', 1)
                 
                 print header
                 
                 with open('sina.html', 'wb') as f:
                 
                     f.write(html)
                     
                     
            10. 现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。
                 
             

         * 服务器
         
           1. 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。
              如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。
              
           2. 所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。
              由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。
              一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 
              
           3. 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。
           
              s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
              
           4. 然后，我们要绑定监听的地址和端口。
              服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。
              127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。
              
           5. 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定：
           
              s.bind(('127.0.0.1', 9999))   # 监听端口
              
           6. 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：
           
           
              s.listen(5)
              
              print 'Waiting for connrction...'
              
           7. 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:
           
              while True:
              
                     sock, addr = s.accept()
                     
                     t = threading.Thread(target = tcplink, agrs = (sock, addr))
                     t.start()
                     
           8. 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：
           
              def tcplink(sock, addr):
              
                     print 'Accept new connection from %s: %s...' % addr
                     
                     sock.send('Welcome!')
                     
                     while True:
                     
                            data = sock.recv(1024)
                            
                            time.sleep(1)
                            
                            if data == 'exit' or not data:
                            
                                   break
                                   
                            sock.send('Hello, %s!' % data)
                            
                     sock.cloase()
                     
                     print 'Connrction from %s: %s closed.' % addr
                     
            9. 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。
               要测试这个服务器程序，我们还需要编写一个客户端程序：
               
               s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
               
               s.connect(('127.0.0.1', 9999))
               
               print s.recv(1024)
               
               for data in ['Michael', 'Tracy', 'Sarah']:
               
                     s.send(data)
                     
                     print s.recv(1024)
                     
               s.send('exit')
               
               s.close()
               
               
            10. 我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了：
                需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。
                
            11. 用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，
                然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。
                同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。
            
           
           
           
           
           
           
           
           
           
           
           
           
               
            



    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            
