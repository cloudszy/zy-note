## 正则表达式 Regular Expression

        * 字符
        
          '00\d' 可以匹配'007'，但是无法匹配'00A'     '\d' 匹配一个数字
          
          '\d\d\d' 可以匹配'010'
          
          '\w\w\d' 可以匹配'py3'                     '\w' 匹配一个字母或数字
          
          'py.'可以匹配:'pyc'  'pyo'  'py!'          '.'  可以匹配任意字符
          
          '*' 可以匹配任意个字符(包括0各)
          
          '+' 可以表示至少一个字符
          
          '?' 可以表示0个或1个字符
          
          '{n}' 可以表示n个字符
          
          '{n，m}' 可以表示n-m个字符
          
          '\s' 可以表示一个空格，(也包括Tab等空白符)
          
          例子：\d{3}\s+\d{3,8}
          
          1.\d{3}表示匹配3个数字，例如'108'；
          
          2.\s可以匹配一个空格(也包括Tab等空白符)，\s+表示至少有一个空格，例如匹配 ' ','   '等：
          
          3.\d{3，8}表示3-8个数字，列如'12345678'
          
          4.例子：\d{3}\s+\d{3,8}则可以匹配任意空格带区号的电话号码：012 123456
          
          5.'-'是特殊字符，需要用'\'转义，\d{3}\-\d{3,8}: 012-123456
          
        * 进阶 '[]'，表示范围，可以做更精准的匹配
              
          [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；
          
          [0-9a-zA-z\_]+可以匹配至少由一个数字，字母或者下划线组成的字符串，比如:'a100', '0_Z', 'py3000'；
          
          [a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开通，后接任意个由一个数字、字母或者下划线组成的字符串
          
          [a-zA-Z\_][0-9a-zA-Z\_]{0, 19} 精准地限制变量的长度是1-20个字符(前面1个字符+后面最多19个字符)
          
          'A|B' 可以匹配A或者B，（P|p）thon可以匹配'Python'或者'python'
          
          '^' 表示行的开头，'^\d' 表示必须以数字开头
          
          '$' 表示行的结束， '\d$' 表示必须以数字结束
          
          py可以匹配'python'，但是加上^py$就变成了整行匹配，只能匹配'py'
          
        * re模块  
          
          s = 'ABC\\-001'  #  python的字符串
          
          'ABC\-001'       #  对应的正则表达式字符串变成
          
          s = r'ABC\-001'   # 使用r前缀，就不需要考虑转义的问题
          
          'ABC\-001'   
          
          math()方法判断正则表达式是否能匹配成功，匹配成功返回Match对象，否则返回None
          
          ```python
          
          import re
          
          re.match(r'^\d{3}\-\d{3,8}$', '010-12345')    # 匹配成功  返回Match对象
          
          re.match(r'^\d{3}\-d{3,8}$', '010 12345')     # 匹配失败  返回空值  None
          
          ```
          
          常见的正则表达式判断方法：
          
          ```python
          
          test = '用户输入的字符串'
          
          if re,match(r'正则表达式', test):
          
              print 'ok'
              
          else:
          
              print 'failed'
              
         ```    
         
       * 切分字符串
       
         ```python
         
         'a b    c'.split('')
         
         ```
         ['a', 'b', '','','','c']  # 正常切分代码，无法识别连续空格
         
         ```python
         
         re.split(r'\s+', 'a b    c')
         
         ```
         ['a', 'b', 'c']  # 正则表达式，正常分割连续空格
         
         ```python
         
         re.split(r'[\s\,]+', 'a,b, c  d')
         
         ```
         ['a', 'b', 'c', 'd']    # 无论多少个空格都可以正确切分
         
         ```pythn
         
         re.split(r'[\s\,\;]+', 'a,b;;c  d')  # ;一样可以识别
         
         ```
         ['a', 'b', 'c', 'd']
         
       * 分组  '()',表示提取分组(Group)
       
         ```python
         
         m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345') # 分别定义了2个组().()
         
         m
         
         print m.group(0)  # 定义了组，就可以在Match对象上用group()方法提取子串
         
         print m.group(1)
         
         print m.group(2)
         
         ```
         '010-12345'
         
         '010'
         
         '12345'
         
         group永远是原始字符串
         
         ```python
         
         t = '19: 05: 30'
         
         m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:
         (0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
         
         m.groups()
         
         ```
         ('19', '05', '30')
         
       * 贪婪匹配 正则表达式是默认贪婪匹配，也就是尽可能的匹配多的字符
       
         ```python
         
         re.match(r'^(\d+)(0*)$', '102300').groups()
         
         ```
         ('102300', '')
         
         由于 '\d+' 采用贪婪匹配，直接把后面0全部匹配了，结果0*只能匹配空字符串了
         
         采用非贪婪匹配，'\d+？' 加个'？'即可
         
         ```python
         
         re.match(r'^(\d+?)(0*)$', '102300').groups()
         
         ```
         ('1023', '00')
         
       * 编译 在python中使用正则表达式时，re模块内部会干两件事情
       
         1.编译正则表达式，如果正则表达式的字符串本身不合法，会报错
         2.用编译的正则表达式去匹配字符串
         
         ```python
         
         import re  # 导入re模块
         
         re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')  # 编译正则表达式 (re_telephpne),等于一个可以随时调用的正则表达式字符串，函数
         
         print re_telephone.match('010-12345').group()      # 匹配1  直接调用正则表达式去匹配即可
         
         print re_telephone.match('010-8086').groups()      # 匹配2
         
         ```
        ('010', '12345')
        ('010', '8086')
        
        编译过的Regular Expression对象，也就是赋值到的变量自身包含了正则表达式，可以直接调用即可
        
      
       
         
         
         
         
         
         
         
       
       
         
              
              
          
          
          
          
         
         
        
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
